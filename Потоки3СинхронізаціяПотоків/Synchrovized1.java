package Потоки3СинхронізаціяПотоків;




// Блокировки
      // В основном хранилище для каждого объекта поддерживается блокировка (lock), над которой
        //можно произвести два действия - установить (lock) и снять (unlock). Только один поток в
        //один момент времени может установить блокировку на некоторый объект. Если до того,
        //как этот поток выполнит операцию unlock, другой поток попытается установить блокировку,
        //его выполнение будет приостановлено до тех пор, пока первый поток не отпустит ее.
        //Операции lock и unlock накладывают жесткое ограничение на работу с переменными в
        //рабочей памяти потока. После успешно выполненного lock, рабочая память очищается, и
        //все переменные необходимо заново считывать из основного хранилища. Аналогично,
        //перед операцией unlock необходимо все переменные сохранить в основном хранилище.
        //Важно подчеркнуть, что блокировка является чем-то вроде флага. Если блокировка на
        //объект установлена, это не означает, что этим объектом нельзя пользоваться, что его
        //поля и методы становятся недоступными - это не так. Единственное действие, которое
        //становится невозможным - установить эту же блокировку другому потоку до тех пор, пока
        //первый поток не выполнит unlock.
        //В Java-программе для того, чтобы воспользоваться механизмом блокировок, существует
        //ключевое слово synchronized. Оно может быть применено в двух вариантах - для
        //объявления synchronized-блока и как модификатор метода. В обоих случаях действие его
        //примерно одинаковое.
        //ПотокиПериванняПотоків-блок записывается следующим образом:
//synchronized (ref) {
//Прежде чем начать выполнять действия, описанные в этом блоке, поток обязан установить
        //блокировку на объект, на который ссылается переменная ref (поэтому она не может быть
        //null). Если другой поток уже установил блокировку на этот объект, то выполнение первого
        //потока приостанавливается до тех пор, пока не удастся выполнить операцию lock.
        //После этого блок выполняется. В случае успешного либо не успешного завершения
        //исполнения, производится операция unlock, чтобы освободить объект для других потоков.




//Якщо брати програму яка не викоритовує потоки то у ній усі методи виконуться почергово відносно того в якому порядку вони записані в головному класі або логіки програми тому не
// має можливості того що два методи можуть одночано бути запущені на одному обєкті
//В програмі яка використовує потоки методи виконуються одночасно для цього і є багатопотоковість щоб програма могла виконувати декілька(методів)операцій одночасно і
// в такому випадку можуть виникати проблеми, коли два або більше методи з різних потоків одночасно парцюють на однім обєкті тоді існує можливсть того що
// один з методів не буде запущено. Дану проблему вирішує синхронізація. Синхронізація це тоді коли метод який запущений на певнім обєкті(ресурсі) блочить його і інші методи не зможуть працювати з даним
// обєктом поки не закінчить роботу перший метод, даний механізм працює так що якщо обєкт заблочений якимось методом тоді інші методи чекають поки він не розблочиться
// це гарантує те що методи будуть гарантовано запущені


//У даній програмі показано роботу механізму  синхронізації потоків в багатопотоковій програмі.Програма працює наступним чином -  тут створється обєкт resorse з певними полями
// і присвоюється деяке значення.Після цього створються два потоки в цих потоках відбувається збільшення значення поля і на 1 тобто два потоки
//  одночасно будуть працювати з одним обєктом (змінювати значення його полів) і це може викликати неточності в роботі викликані тим що методи з двох потоків можуть одночасно
// спробувати змінити занчення поля обєкта в такому випадку один з методів не запутиться.

//

public class Synchrovized1 { public static void main(String[] args) throws InterruptedException {
    Resorse resorse = new Resorse(); //3)Створення обєкта з яким будуть проводитись операції
    resorse.i=5; //4)Полю данного обэкта присвоюэться значення
    MyThread myThread =new MyThread();
MyThread myThread1 =new MyThread();

myThread.setResorse(resorse);// 5)
myThread1.setResorse(resorse);
myThread.start();
myThread1.start();
myThread.join();
myThread1.join();
    System.out.println(resorse.i);


}}

class MyThread extends Thread {//1)Стандартно створються клас який ексдендить Thread для створення потоків

    Resorse resorse;//Це є поле типу Resorse його значення це обєкти даного класу воно створене для того щоб мати доступ до обэктів даного класу з іншого класу

    public void setResorse(Resorse resorse) {//Це є сетер через який вводиться обєкт
        this.resorse = resorse;
    }

    @Override
    public void run() {
        resorse.changeI();
    }}


    //2)Створюється певний клас і в ньому поле яким потрібно оперувати змінювати його
    class Resorse{
    int i;
    public synchronized void changeI(){ //Метод який буде змінювати значення даного поля
                                       // synchronized- даний запис означає що метод буде працювати синхронно
                                       // тобто даний  методи з обєктом  класу буде працювати почегово поки один метод не закінчить роботу інший не запуститься

        int i= this.i;
        i++;
        this.i=i;

    }}
//synchronized (this){} //Також синхронізованими можуть бути блоки