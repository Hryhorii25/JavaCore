package Потоки2ЖиттєвийЦиклПотоків;
//Життєві цикли потоків
//В загальному даний процес працює наступним чином  у JVM є є певний механізм який називається Sheduler він автоматично  керує потоками,часом їхньго
// виконання  переходом потоків у різні стани(життєві цикли), даним механізмом можна певним чином керувати через певні методи.
// Представим у нас є  декілька потоків і в кожен момент часу виконується тільки один всі інші знаходяться в стані Runnable (очікування)
// і вони почерзі міняються один іде в Running(Виконується) решта ідуть в Runnable(Очікують).Увесь механізм роботи потоків, переходу потоків між станами може
// працювати автомтично або може бути керованим відносно логіки програми

//1)CDI1IOCandDependencyInjection- як тільки викликається метод start потік буде у даному стані (CDI1IOCandDependencyInjection) Новий , при цьому даний потік ще не запущений у роботу
//2)Runnable- після регістрації (виклику метода start) потік потрапляє в pool потоків (кучу потоків) в якій він зберігається і він буде таким який може бути запущений
//при цьому даний потік ще не працює
//3)Running- це стан потоку в якому він працює виконується,але в будь який момент він може зупинитися

//4)Waiting blocing sliping - при цьому деякі потоки з стану Running(працюючий) можуть попадати в окремі стнани які називаються:

//4.1)Sliping -потік може заснути коли він засинає він виходть із стану  Runnable(Очікування) або Running(Виконання) і на втановлений час після того як даний час пройшав
// потік поветається у стан  Runnable(Очікування) але це не гарантує одразу ж його запуску

//4.2)Waiting - поток може призупинитись

//4.3)Blocing - поток може блокуватись


public class Main { public static void main(String[] args) throws InterruptedException {
    MyThread myThread = new MyThread();


    myThread.start();

    //Методи керування станами потоків

    myThread.sleep(20000);//Метод переводить потік який виконується в стан сну на втановлений час

    //Методи які виставляють пріорітетність виконання потоку можна задавати двома способами
    myThread.setPriority(Thread.MAX_PRIORITY);
    myThread.setPriority(Thread.MIN_PRIORITY);
    myThread.setPriority(Thread.NORM_PRIORITY);
    myThread.setPriority(7);// 1 - min 10 - max

    Thread.yield();// Метод будь який потік який виконується в даний час  преводить у стан Runnable(Очікування) являється статичним методом
    myThread.join();// Метод гарантує повне виконання даного потоку і при його виконанні жоден інший потік не буде запускатись
    myThread.join(1000);// Метод гарантує виконання даного потоку на протязі встановленого часу і при його виконанні жоден інший потік не буде запускатись

}
}

class MyThread extends Thread {
    @Override
    public void run() {

            System.out.println("running name");
        }}

//Java Thread Join — метод, который может быть использован для того, чтобы приостановить выполнение текущего потока до тех пор,
// пока другой поток не закончит свое выполнение. Есть три перегруженных метода join().


//Java Thread Join(). Теория
//public final void join(). Этот метод приостановит выполнение текущего потока до тех пор, пока другой поток не закончит свое выполнение.
// Если поток прерывается, бросается InterruptedException.

//public final synchronized void join(long millis): Этот метод приостановит выполнение текущего потока на указанное время в миллисекундах.
// Выполнение этого метода зависит от реализации ОС, поэтому Java не гарантирует, что текущий поток будет ждать указанное вами время.



//public final synchronized void join(long millis, int nanos): Этот метод приостановит выполнение текущего потока до тех пор,
// пока другой поток не закончит свое выполнение на время заданное в миллисекундах плюс наносекундах.Вот простой пример,
// показывающий использование метода join(). Цель программы: убедиться в том, что третий поток начнет работу только тогда,
// когда первый закончит выполнение.