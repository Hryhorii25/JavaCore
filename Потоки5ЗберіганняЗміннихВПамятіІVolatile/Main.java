package Потоки5ЗберіганняЗміннихВПамятіІVolatile;
       // Хранение переменных в памяти
//Виртуальная машина поддерживает основное хранилище данных (main storage), в котором сохраняются значения всех переменных и которое
// используется всеми потоками. Под переменными здесь понимаются поля объектов и классов, а также элементы массивов.Что касается
// локальных переменных и параметров методов, их значения не могут быть доступы другим потокам, поэтому они не представляют интереса.
// Для каждого потока создается его собственная рабочая память (working memory), в которую копируются значения всех переменных перед
// использованием.
//Рассмотрим основные операции, доступные для потоков при работе с памятью:
        //• use - чтение значения переменной из рабочей памяти потока
        //• assign - запись значения переменной в рабочую память потока
        //• read - получение значения переменной из основного хранилища
        //• load - сохранение значения переменной, прочитанного из основного хранилища, в рабочей памяти
       // • store - передача значения переменной из рабочей памяти в основное хранилище для будущего сохранения
       // • write - сохраняет в основном хранилище значение переменной, переданной командой store
//Подчеркнем, что перечисленные команды не являются методами каких-либо классов, они не доступны программисту.
// Сама виртуальная машина использует их для обеспечения корректной работы потоков исполнения. Поток, работая с переменной,
// регулярно применяет команды use и assign для использования ее существующего значения и присвоения нового. Кроме этого,
// должны осуществлятьсядействия по передачи значений из/в основное хранилище. Они выполняются в два этапа.
//При получении данных сначала основное хранилище считывает значение командой read,
//а затем поток сохраняет результат в своей рабочей памяти командой load. Эта пара команд
       // всегда выполняется вместе именно в таком порядке, т.е. нельзя выполнить одну, не
        //выполнив другую. При отправлении данных сначала поток считывает значение из рабочей
       // памяти командой store, а затем основное хранилище сохраняет его командой write. Эта
        //пара команд также всегда выполняется вместе именно в таком порядке, т.е. нельзя
        //выполнить одну, не выполнив другую.
        //Набор этих правил составлялся с тем, чтобы операции с памятью были достаточно строги
       // для точного анализа их результатов, а с другой стороны правила должны оставлять
       // достаточное пространство для различных технологий оптимизаций (регистры, очереди,
       // кэш и т.д.).
        //Последовательность команд подчиняется следующим правилам:
       // • все действия, выполняемые одним потоком строго упорядочены, т.е. выполняются одно за другим
        //• все действия, выполняемые с одной переменной в основном хранилище памяти, строго
        //упорядочены, т.е. следуют одно за другим
        //За исключением некоторых дополнительных очевидных правил больше никаких ограничений
        //нет. Например, если поток изменил значение сначала одной, а затем другой переменной,
       // то они эти изменения могут быть переданы в основное хранилище в переставленном порядке.
        //Поток создается с чистой рабочей памятью и должен загрузить все необходимые
       // переменные из основного хранилища перед использованием. Любая переменная сначала
       // создается в основном хранилище и лишь затем копируется в рабочую память потоков, которые будут ее использовать.
        //Таким образом, потоки никогда не взаимодействуют друг с другом на прямую, только через главное хранилище.



// Модификатор volatile
//При объявлении полей объектов и классов может быть указан модификатор volatile. Он
       // устанавливает более строгие правила работы со значениями переменных.
        //Если поток собирается выполнить команду use для volatile переменной, то требуется,
        //чтобы предыдущим действием над этой переменной было обязательно load, и наоборот
        //- операция load может выполняться только перед use. Таким образом, переменная и
        //главное хранилище всегда имеют самое последнее значение этой переменной.
        //Аналогично, если поток собирается выполнить команду store для volatile переменной, то
        //требуется, чтобы предыдущим действием над этой переменной было обязательно assign,
       // и наоборот - операция assign может выполняться только если следующей будет store.
        //Таким образом, переменная и главное хранилище всегда имеют самое последнее значение
        //этой переменной.
       // Наконец, если проводятся операции над несколькими volatile переменными, то передача
        //соответствующих изменений в основное хранилище должно проводится строго в том же
        //порядке.При работе с обычными переменными компилятор имеет больше пространства для маневра.
        //Например, при благоприятных обстоятельствах может оказаться возможным предсказать
        //значение переменной, заранее вычислить и сохранить его, а затем в нужный момент
        //использовать уже готовым.
        //Нужно обратить внимание на два 64-разрядных типа double и long. Поскольку многие
        //платформы поддерживают лишь 32-битную память, величины этих типов рассматриваются
        //как две переменные, и все описанные действия делаются независимо для двух половинок
        //таких значений. Конечно, если производитель виртуальной машины считает возможным,
        //он может обеспечить атомарность операций и над этими типами. Для volatile переменных
        //это является обязательным требованием.



//Volatail це ключове слово яке говорить потоку щоб ключові перемінні не були закиширивані і завжди записувались в головну основну память
// це працює наступним чином два потоки і в даних потоках є перемінні які задіються десь там в циклах якщо дана перемінна volatile тоді вона не
// буде локальною при своїй зміні в будь якому процесі вона буде мінятись усюди, навіть якщо вона локальна переміння циклу for(i)
//При використанні перемінної з  Volatail  її значення можна буде безпечно змінювати з використанням потоків без використання синхронізованих методів

public class Main {
    static volatile int  i ;
    public static void main(String[] args) throws InterruptedException {
       new  MyThreadRead().start();
       new  MyThreadWrite().start();


    }
    static class MyThreadWrite extends Thread {

        @Override
        public void run() {

            while (i<5){
               System.out.println("increment i"+(++ i));
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            super.run();
        }
    }

    static class MyThreadRead extends Thread {

        @Override
        public void run() {
            int localVar = i;
            while (localVar<5){
                if (localVar !=i){
                    System.out.println("new value i is"+ i);
                    localVar =i;
                }
            }
            super.run();
        }
    }}











































